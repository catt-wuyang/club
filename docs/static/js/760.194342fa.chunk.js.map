{"version":3,"file":"static/js/760.194342fa.chunk.js","mappings":"iHAAA,sihB","sources":["fragments/20220802.md"],"sourcesContent":["export default \"### 【前端学算法】04.树\\n\\n![image](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d79c25493a05471da58f434fb74e57cb~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp?)\\n\\n### 🐧 前情提要\\n\\n阅读本章节你会了解到以下内容：\\n\\n1.  树的理解\\n2.  二叉树的遍历\\n3.  二叉树的属性\\n4.  二叉树的操作\\n5.  LeetCode 刷题公式\\n6.  LeetCode 题目分类\\n\\n---\\n\\n### 1. 树的理解\\n\\n**（1）数据结构**\\n\\n树是一种数据结构，是由 n 个节点组成的具有层次关系的集合。结构图很像一棵倒置的树，根节点在最上层，叶子节点依次排列在下面逐层。\\n\\n```js\\n// 最常用的二叉树的数据结构表示\\nconst TreeNode = function (val) {\\n  this.val = val;\\n  this.left = null;\\n  this.right = null;\\n};\\n```\\n\\n**（2）树的特性**\\n\\n- 每个节点都有有限个子节点，或没有子节点\\n- 树中仅有根节点没有父节点\\n- 除根节点外，其他节点只有一个父节点\\n- 树中没有环路\\n\\n**（3）树的概念**\\n\\n- 根节点：树中仅有一个根节点，没有父节点的节点被称为根节点 root，理解为树的源头\\n- 父节点：一个节点有子节点，则称该节点为其子节点的父节点 parent node（相对概念）\\n- 子节点：一个父节点可能同时拥有多个子节点 children node (相对概念)\\n- 兄弟节点：相同父节点的节点，之间互称为兄弟节点 sibling node\\n- 叶子节点：子树最底层，没有子节点的节点 leaf node\\n- 深度：树中的任意节点 n，即从根节点到节点 n 的唯一路径长度，根节点的深度为 0\\n- 树的深度：从根节点到叶子节点的所有路径中，最长的那条路径的长度 depth\\n- 高度：树中的任意节点 n，到其叶子节点的最长路径的长度，叶子节点的高度为 0 height\\n- 节点的度：一个节点含有的子树的个数，称为该节点的度\\n- 树的度：一棵树中，所有节点的度的最大值，称为该树的度 level\\n- 节点值：当前节点对应的数值 root.val\\n\\n**（4）树的种类**\\n\\n树数据结构中可能种类较多，仅说明以下几个前端经常用到的\\n\\n- 二叉树：每个节点最多含有两个子树\\n  - 平衡二叉树：每个节点的子树高度差不大于 1 的二叉树\\n  - 完美二叉树：对于一棵二叉树，除了其最底层节点外，其余各层的节点的数目都达到最大值\\n- 二叉搜索树：左子树上的所有节点值，均小于它的根节点值；\\n  右子树上的所有节点值，均大于它的根节点值；\\n- N 叉树：每个节点含有 n 个子树\\n\\n### 2.树的遍历\\n\\n对于树来说，最需要掌握的就是对树的遍历，很多延伸都是在遍历的前提下进行的，以下列举常用对树的遍历的方式：\\n\\n- 二叉树的前序、中序、后序遍历\\n- 二叉树的层序遍历\\n- 二叉搜索树的遍历\\n- N 叉树的前序、后序、层序遍历\\n\\n**（1）二叉树的前序、中序、后序遍历**\\n\\n利用 DFS 深度优先遍历 + 递归，依次遍历左子树、右子树，前序、中序、后序的区别在于，在什么遍历的位置处理填充值\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b69e6bdac45c4627aad15a2b10f7a403~tplv-k3u1fbpfcp-watermark.image?)\\n\\n- 前序遍历：Pre-Order Traversal 先访问根节点，再访问子树节点\\n- 中序遍历：In-Order Traversal 先访问左子树，再访问根节点，最后访问右子树\\n- 后序遍历：Post-Order Traversal 先访问子树节点，再访问根节点\\n\\n```js\\nconst orderTraversal = function (root) {\\n  let ret = [];\\n  const dfs = function (node) {\\n    if (root === null) return;\\n\\n    /* ret.push(root.val) 前序 */\\n    root.left && dfs(root.left);\\n    ret.push(root.val); // 中序\\n    root.right && dfs(root.right);\\n    /* ret.push(root.val) 后序 */\\n  };\\n\\n  dfs(root);\\n  return ret;\\n};\\n```\\n\\n**（2）二叉树的层序遍历**\\n\\n利用 BFS 广度优先遍历 + 队列先进先出特性；len 记录树中每层节点的数量，curLevel 数组集合记录每层节点的值；分别遍历左子树、右子树依次入队列\\n\\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18bcc4dc42654ff2b67492c761b54b03~tplv-k3u1fbpfcp-watermark.image?)\\n\\n层序遍历：Level-Order Traversal 先访问离根节点最近的节点，逐层访问树\\n\\n```js\\nconst levelTaversal = function (root) {\\n  let ret = [];\\n  if (root === null) return ret;\\n\\n  let queue = [];\\n  queue.push(root);\\n  while (queue.length) {\\n    let len = queue.length;\\n    let curLevel = [];\\n    while (len > 0) {\\n      let node = queue.shift();\\n      curLevel.push(node.val);\\n\\n      node.left && queue.push(node.left);\\n      node.right && queue.push(node.right);\\n      len--;\\n    }\\n    ret.push(curLevel);\\n  }\\n  return ret;\\n};\\n```\\n\\n### 3. 二叉树的属性\\n\\n二叉树的属性，包括最小深度、最大深度、树的直径等。以下是解题思路：\\n\\n（1）二叉树的直径\\n\\n- 先理解二叉树直径的概念，任意两个节点路径长度的最大值\\n- 涉及到路径，最先想到用 DFS 这种遍历方式\\n- 返回值是一个整数，创建 ret 记录路径的最大值\\n- 考虑 root === null 时，二叉树的深度为 0\\n- 依次遍历左右子树，并记录左、右子树的深度\\n- 最后返回 +1 算上根节点\\n\\n```js\\nconst diameter = function (root) {\\n  let ret = 0;\\n  const dfs = function (root) {\\n    if (root === null) return ret;\\n    const left = dfs(root.left);\\n    const right = dfs(root.right);\\n\\n    ret = Math.max(ret, left + right);\\n    return Math.max(left, right) + 1;\\n  };\\n\\n  dfs(root);\\n  return ret;\\n};\\n```\\n\\n(2)二叉树的最大深度\\n\\n最大深度，意思是从根节点到叶子节点，最长路径上的所有节点数\\n转换成逻辑语言，理解为左子树的深度、右子树的深度的最大值 + 1 根节点\\n\\n```js\\nconst maxDepth = function (root) {\\n  if (root === null) return 0;\\n  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\\n};\\n```\\n\\n（3）二叉树的最小深度\\n\\n最小深度，意识是从根节点到叶子节点，最短路径上的所有节点数\\n转换成逻辑语言，理解为左子树的深度、右子树的深度的最小值 + 1 根节点\\n\\n```js\\nconst minDepth = function (root) {\\n  if (root === null) return 0;\\n\\n  let queue = [root];\\n  let depth = 1;\\n  while (queue.length) {\\n    let len = queue.length;\\n    while (len--) {\\n      let node = queue.shift();\\n      if (node.left === null && node.right === null) {\\n        return depth;\\n      }\\n      node.left && queue.push(node.left);\\n      node.right && queue.push(node.right);\\n    }\\n    depth++;\\n  }\\n  return root;\\n};\\n```\\n\\n### 4. 二叉树的操作\\n\\n二叉树的操作，包括翻转二叉树、合并二叉树...\\n\\n（1）翻转二叉树\\n\\n递归的一般思路是，先找递归的子问题，再考虑终止条件\\n\\n```js\\nconst invertTree = function (root) {\\n  if (root === null)\\n    return (root[(root.left, root.right)] = [\\n      invertTree(root.right),\\n      invertTree(root.left),\\n    ]);\\n  return root;\\n};\\n```\\n\\n（2）合并二叉树\\n\\n```js\\nconst mergeTree = function (root1, root2) {\\n  if (root1 === null) return root2;\\n  if (root2 === null) return root1;\\n\\n  let ret = new TreeNode(root1.val + root2.val);\\n  ret.left = mergeTree(root1.left, root2.left);\\n  ret.right = mergeTree(root1.right, root2.right);\\n\\n  return ret;\\n};\\n```\\n\\n### 5. leetcode 刷题公式\\n\\n以下是做树题目能够用到的最基本的公式。刷题时会发现基本都是这两种公式的变形，先理解树的概念，思考做题时可以用到哪些方式解题。需要注意的是，某类题目刷到一定量时，要停下来总结下相似点，还有什么更好的解题思路么... 而不是一直盲目的追求刷题的数量，刷 500 道题不是目的，遇到题了能解出来，能优化解题思路，才是更重要的\\n\\n解题思路步骤：\\n\\n- 读题，清楚并能转换题目需求，涉及到树的基本概念要理解，不断积累解题思路\\n- 考虑是利用 DFS 还是 BFS 解题，区别在于遍历方式不同。有时可能两种都可以解出来，前期用你能理解的解题思路做，能理解挺重要的。随着后期接触的多了，可以深入了解不同的解题思路和方式，选择更高效复杂度更低的\\n- 确定之后，把对应的公式默写出来\\n- 看返回值，考虑是否需要创建 ret，还是可以直接修改当前树，作为返回值\\n- 递归的边界条件，以及 root === null 时返回值\\n- 细节处理，具体根据题目要求转换成逻辑代码\\n\\n**（1）DFS 深度优先遍历 + 递归**\\n\\n```js\\nlet ret = [];\\n\\nconst dfs = function (root) {\\n  if (root === null) return;\\n\\n  ret.push(root.val);\\n  root.left && dfs(root.left);\\n  root.right && dfs(root.right);\\n};\\n\\ndfs(root);\\nreturn ret;\\n```\\n\\n**（2）BFS 广度优先遍历 + 队列**\\n\\n```js\\nlet ret = [];\\nif (root === null) return ret;\\n\\nlet queue = [root];\\nwhile (queue.length) {\\n  let len = queue.length;\\n  let curLevel = [];\\n  while (len > 0) {\\n    let node = queue.shift();\\n    curLevel.push(root.val);\\n    node.left && queue.push(node.left);\\n    node.right && queue.push(node.right);\\n    len--;\\n  }\\n}\\n\\nreturn ret;\\n```\\n\\n### 6. LeetCode 题目分类\\n\\n集中分类刷 LeetCode 树相关题目时，可以按照如下建议顺序来做题\\n\\n- 二叉树的遍历\\n  - 94.二叉树的中序遍历\\n  - 144.二叉树的前序遍历\\n  - 145.二叉树的后序遍历\\n  -\\n  - 102.二叉树的层序遍历 - 自顶向下\\n  - 107.二叉树的层序遍历 II - 自底向上\\n  - 199.二叉树的层序遍历 - 右视图\\n  - 513.二叉树的左下角的值 - 左视图\\n  - 637.二叉树的每层平均值\\n  - 515.二叉树每层的最大值\\n  -\\n  - 429.N 叉树的层序遍历\\n  - 589.N 叉树的前序遍历\\n  - 590.N 叉树的后序遍历\\n  -\\n  - 98.验证二叉搜索树\\n  - 99.恢复二叉搜索树\\n  - 700.二叉搜索树中的搜索\\n  - 701.二叉搜索树中插入值\\n  - 230.二叉搜索树中第 k 小的元素\\n  - 108.数组转换二叉搜索树\\n  - 109.链表转换二叉搜索树\\n  -\\n  - 112.二叉树的路径总和\\n  - 113.二叉树的路径总和 II\\n  - 257.二叉树的所有路径\\n- 二叉树的操作\\n  - 100.相同二叉树\\n  - 101.对称二叉树\\n  - 226.翻转二叉树\\n  - 617.合并二叉树\\n  - 116.填充二叉树\\n- 二叉树的属性\\n  - 111.二叉树的最小深度\\n  - 104.二叉树的最大深度\\n  - 543.二叉树的直径\\n  - 236.二叉树的最近祖先\\n  - 235.二叉搜索树的最近祖先\\n\";"],"names":[],"sourceRoot":""}